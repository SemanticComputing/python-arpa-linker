<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>arpa API documentation</title>
    <meta name="description" content="A module for linking resources to an RDF graph with an [ARPA](https://github.com/jiemakel/arpa) serv..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#arpa.LABEL_PROP">LABEL_PROP</a></li>
    <li class="mono"><a href="#arpa.TYPE_PROP">TYPE_PROP</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#arpa.arpafy">arpafy</a></li>
    <li class="mono"><a href="#arpa.combine_candidates">combine_candidates</a></li>
    <li class="mono"><a href="#arpa.log_to_file">log_to_file</a></li>
    <li class="mono"><a href="#arpa.main">main</a></li>
    <li class="mono"><a href="#arpa.map_results">map_results</a></li>
    <li class="mono"><a href="#arpa.parse_args">parse_args</a></li>
    <li class="mono"><a href="#arpa.post">post</a></li>
    <li class="mono"><a href="#arpa.process">process</a></li>
    <li class="mono"><a href="#arpa.process_graph">process_graph</a></li>
    <li class="mono"><a href="#arpa.prune_candidates">prune_candidates</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#arpa.Arpa">Arpa</a></span>
        
          
  <ul>
    <li class="mono"><a href="#arpa.Arpa.__init__">__init__</a></li>
    <li class="mono"><a href="#arpa.Arpa.extract_uris">extract_uris</a></li>
    <li class="mono"><a href="#arpa.Arpa.get_candidates">get_candidates</a></li>
    <li class="mono"><a href="#arpa.Arpa.get_distinct_mentions">get_distinct_mentions</a></li>
    <li class="mono"><a href="#arpa.Arpa.get_uri_matches">get_uri_matches</a></li>
    <li class="mono"><a href="#arpa.Arpa.query">query</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#arpa.ArpaMimic">ArpaMimic</a></span>
        
          
  <ul>
    <li class="mono"><a href="#arpa.ArpaMimic.__init__">__init__</a></li>
    <li class="mono"><a href="#arpa.ArpaMimic.extract_uris">extract_uris</a></li>
    <li class="mono"><a href="#arpa.ArpaMimic.get_candidates">get_candidates</a></li>
    <li class="mono"><a href="#arpa.ArpaMimic.get_distinct_mentions">get_distinct_mentions</a></li>
    <li class="mono"><a href="#arpa.ArpaMimic.get_uri_matches">get_uri_matches</a></li>
    <li class="mono"><a href="#arpa.ArpaMimic.query">query</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">arpa</span> module</h1>
  <p>A module for linking resources to an RDF graph with an <a href="https://github.com/jiemakel/arpa">ARPA</a> service.</p>
<h2>Requirements<a name="requirements"></a></h2>
<p>Python 3, <a href="http://rdflib.readthedocs.org/en/latest/">RDFLib</a> and <a href="http://docs.python-requests.org/en/latest/">Requests</a></p>
<p>If you want to see a progress bar, you'll need <a href="https://github.com/rasbt/pyprind">PyPrind</a>.</p>
<h2>Usage<a name="usage"></a></h2>
<p>The module can be invoked as a script from the command line or by calling <a href="#arpa.arpafy"><code>arpafy</code></a> (or <a href="#arpa.process"><code>process</code></a>) in your Python code.</p>
<pre style="padding:5px">
usage: arpa.py [-h] [--fi INPUT_FORMAT] [--fo OUTPUT_FORMAT] [-n] [-c]
               [--rdf_class CLASS] [--prop PROPERTY]
               [--ignore [TERM [TERM ...]]] [--min_ngram N]
               [--no_duplicates [TYPE [TYPE ...]]] [-r N] [-w N]
               [--log_level {NOTSET,DEBUG,INFO,WARNING,ERROR,CRITICAL}]
               input output target_property arpa

Link resources to an RDF graph with ARPA.

positional arguments:
  input                 Input rdf file
  output                Output file
  target_property       Target property for the matches
  arpa                  ARPA service URL

optional arguments:
  -h, --help            show this help message and exit
  --fi INPUT_FORMAT     Input file format (rdflib parser). Will be guessed if
                        omitted.
  --fo OUTPUT_FORMAT    Output file format (rdflib serializer). Default is
                        turtle.
  -n, --new_graph       Add the ARPA results to a new graph instead of the
                        original. The output file contains all the triples of
                        the original graph by default. With this argument set
                        the output file will contain only the results.
  -c, --candidates_only
                        Get candidates (n-grams) only from ARPA.
  --rdf_class CLASS     Process only subjects of the given type (goes through
                        all subjects by default).
  --prop PROPERTY       Property that's value is to be used in matching.
                        Default is skos:prefLabel.
  --ignore [TERM [TERM ...]]
                        Terms that should be ignored even if matched
  --min_ngram N         The minimum ngram length that is considered a match.
                        Default is 1.
  --no_duplicates [TYPE [TYPE ...]]
                        Remove duplicate matches based on the 'label' returned
                        by the ARPA service. Here 'duplicate' means a subject
                        with the same label as another subject in the same
                        result set. A list of types can be given with this
                        argument. If given, prioritize matches based on it -
                        the first given type will get the highest priority and
                        so on. Note that the response from the service has to
                        include a 'type' variable for this to work.
  -r N, --retries N     The amount of retries per query if a HTTP error is
                        received. Default is 0.
  -w N, --wait N        The number of seconds to wait between retries. Only
                        has an effect if number of retries is set. Default is
                        1 second.
  --log_level {NOTSET,DEBUG,INFO,WARNING,ERROR,CRITICAL}
                        Logging level, default is INFO.
  --log_file LOG_FILE   The log file. Default is arpa_linker.log.
</pre>

<p>The arguments can also be read from a file using "@" (example arg file <a href="https://github.com/SemanticComputing/python-arpa-linker/blob/master/arpa.args">arpa.args</a>):</p>
<p><code>$ python3 arpa.py @arpa.args</code></p>
<h2>Examples<a name="examples"></a></h2>
<p>See <a href="https://github.com/SemanticComputing/warsa-linkers">this repo</a> for code examples,
and <a href="https://github.com/SemanticComputing/python-arpa-linker/blob/master/arpa.args">arpa.args</a> for an example arg file.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa', this);">Show source &equiv;</a></p>
  <div id="source-arpa" class="source">
    <pre><code>"""
A module for linking resources to an RDF graph with an [ARPA](https://github.com/jiemakel/arpa) service.

## Requirements<a name="requirements"></a>
Python 3, [RDFLib](http://rdflib.readthedocs.org/en/latest/) and [Requests](http://docs.python-requests.org/en/latest/)

If you want to see a progress bar, you'll need [PyPrind](https://github.com/rasbt/pyprind).

## Usage<a name="usage"></a>

The module can be invoked as a script from the command line or by calling `arpa.arpafy` (or `arpa.process`) in your Python code.

<pre style="padding:5px">
usage: arpa.py [-h] [--fi INPUT_FORMAT] [--fo OUTPUT_FORMAT] [-n] [-c]
               [--rdf_class CLASS] [--prop PROPERTY]
               [--ignore [TERM [TERM ...]]] [--min_ngram N]
               [--no_duplicates [TYPE [TYPE ...]]] [-r N] [-w N]
               [--log_level {NOTSET,DEBUG,INFO,WARNING,ERROR,CRITICAL}]
               input output target_property arpa

Link resources to an RDF graph with ARPA.

positional arguments:
  input                 Input rdf file
  output                Output file
  target_property       Target property for the matches
  arpa                  ARPA service URL

optional arguments:
  -h, --help            show this help message and exit
  --fi INPUT_FORMAT     Input file format (rdflib parser). Will be guessed if
                        omitted.
  --fo OUTPUT_FORMAT    Output file format (rdflib serializer). Default is
                        turtle.
  -n, --new_graph       Add the ARPA results to a new graph instead of the
                        original. The output file contains all the triples of
                        the original graph by default. With this argument set
                        the output file will contain only the results.
  -c, --candidates_only
                        Get candidates (n-grams) only from ARPA.
  --rdf_class CLASS     Process only subjects of the given type (goes through
                        all subjects by default).
  --prop PROPERTY       Property that's value is to be used in matching.
                        Default is skos:prefLabel.
  --ignore [TERM [TERM ...]]
                        Terms that should be ignored even if matched
  --min_ngram N         The minimum ngram length that is considered a match.
                        Default is 1.
  --no_duplicates [TYPE [TYPE ...]]
                        Remove duplicate matches based on the 'label' returned
                        by the ARPA service. Here 'duplicate' means a subject
                        with the same label as another subject in the same
                        result set. A list of types can be given with this
                        argument. If given, prioritize matches based on it -
                        the first given type will get the highest priority and
                        so on. Note that the response from the service has to
                        include a 'type' variable for this to work.
  -r N, --retries N     The amount of retries per query if a HTTP error is
                        received. Default is 0.
  -w N, --wait N        The number of seconds to wait between retries. Only
                        has an effect if number of retries is set. Default is
                        1 second.
  --log_level {NOTSET,DEBUG,INFO,WARNING,ERROR,CRITICAL}
                        Logging level, default is INFO.
  --log_file LOG_FILE   The log file. Default is arpa_linker.log.
</pre>

The arguments can also be read from a file using "@" (example arg file [arpa.args](https://github.com/SemanticComputing/python-arpa-linker/blob/master/arpa.args)):

`$ python3 arpa.py @arpa.args`

## Examples<a name="examples"></a>

See [this repo](https://github.com/SemanticComputing/warsa-linkers) for code examples,
and [arpa.args](https://github.com/SemanticComputing/python-arpa-linker/blob/master/arpa.args) for an example arg file.
"""

import sys
import argparse
import requests
import time
import logging
from datetime import timedelta
from requests.exceptions import HTTPError
from rdflib import Graph, URIRef, Literal
from rdflib.namespace import RDF, SKOS
from rdflib.util import guess_format

__all__ = ['Arpa', 'ArpaMimic', 'arpafy', 'process', 'process_graph', 'prune_candidates',
            'combine_candidates', 'map_results', 'log_to_file', 'post', 'parse_args',
            'main', 'LABEL_PROP', 'TYPE_PROP']

LABEL_PROP = 'label'
"""The name of the property containing the label of the match in the ARPA results."""

TYPE_PROP = 'type'
"""
The name of the property containing the type of the match in the ARPA results->properties.
Only needed for prioritized duplicate removal.
"""

logger = logging.getLogger(__name__)

# Hide requests INFO logging spam
requests_logger = logging.getLogger('requests')
requests_logger.setLevel(logging.WARNING)


def _get_value(result):
    type_ = result.get('type', None)
    value = result.get('value', '')
    if type_ == 'literal':
        datatype = result.get('datatype', None)
        if datatype:
            return '"{}"^^{}'.format(value, datatype)
        return '"{}"'.format(value)
    if type_ == 'uri':
        return '<{}>'.format(value)
    return value


def map_results(results):
    """
    Map general SPARQL results to the format ARPA returns.

    Return the mapped results.

    `results` is the SPARQL result as a dict. Each row has to include an 'id' variable.
    """

    logger.debug('Mapping results {} to ARPA format'.format(results))

    res = []
    for obj in results['results']['bindings']:
        o_id = obj['id']['value']

        idx = next((index for (index, d) in enumerate(res) if d['id'] == o_id), None)
        if idx is None:
            props = {key: [_get_value(value)] for key, value in obj.items()}
            o = {
                'id': o_id,
                'label': obj.get('label', {}).get('value', ''),
                'matches': [obj.get('ngram', {}).get('value', '')],
                'properties': props
            }
            res.append(o)
        else:
            o = res[idx]
            ngram = obj.get('ngram', {}).get('value', '')
            if ngram not in o['matches']:
                o['matches'].append(ngram)
            for k, v in obj.items():
                p = o.get('properties').get(k, None)
                if p:
                    p.append(_get_value(v))
                else:
                    o['properties'][k] = [_get_value(v)]

    res = {'results': res}

    logger.debug('Mapped to: {}'.format(res))

    return res


def post(url, data, retries=0, wait=1):
    """
    Send a post request to the given URL with the given data, expecting a JSON response.
    Throws a HTTPError if the request fails (after retries, if any) or if JSON
    parsing fails.

    `url` is the URL to send the request to.

    `data` is a dict containing the data to send to the URL.

    `retries` is the number of retries to attempt if the request fails. Optional.

    `wait` is the number of seconds to wait between retries. Optional, default is 1 second.
    Has no effect if `retries` is not set.
    """

    if retries < 0:
        raise ValueError('Invalid amount of retries: {}'.format(retries))
    if wait < 0:
        raise ValueError('Invalid retry wait time: {}'.format(wait))

    tries = retries + 1

    while tries:
        logger.debug('Sending request to {} with data: {}'.format(url, data))
        res = requests.post(url, data)
        try:
            res.raise_for_status()
            res = res.json()
        except (HTTPError, ValueError) as e:
            tries -= 1
            if tries:
                logger.warning('Received error ({}) from {} with request data: {}.'
                        .format(e, url, data))
                logger.warning('Waiting {} seconds before retrying'.format(wait))
                time.sleep(wait)
                continue
            elif retries:
                logger.warning('Error {}, out of retries.'.format(e))
            raise HTTPError('Error ({}) from {} with request data: {}.'.format(e, url, data))
        else:
            # Success
            logger.debug('Success, received: {}'.format(res))
            return res


class Arpa:
    """Class representing the ARPA service"""

    def __init__(self, url, remove_duplicates=False, min_ngram_length=1, ignore=None,
            retries=0, wait_between_tries=1):
        """
        Initialize the Arpa service object.

        `url` is the ARPA service url.

        If `remove_duplicates` is `True`, choose only one subject out of all the
        matched subjects that have the same label (arbitrarily).
        If, instead, the value is a list or a tuple, assume that it represents
        a list of class names and prefer those classes when choosing
        the subject. The ARPA results must include a property (`arpa.TYPE_PROP`)
        that has the class of the match as the value. Optional.

        `min_ngram_length` is the minimum ngram match length that will be included when
        returning the query results. Optional.

        `ignore` is a list of matches that should be removed from the results (case insensitive).
        Optional.

        `retries` is the number of retries per query. Optional.

        `wait_between_tries` is the amount of times in seconds to wait between retries.
        Optional, default is 1 second. Has no effect if `retries` is not set.
        """

        logger.debug('Initialize Arpa instance')

        if retries < 0:
            raise ValueError('Number of retries has to be a non-negative number, got {}'
                    .format(retries))
        if wait_between_tries < 0:
            raise ValueError('Retry wait time has to be a non-negative number, got {}'
                    .format(wait_between_tries))

        self._retries = retries

        self._url = url
        self._ignore = [s.lower() for s in ignore or []]
        self._min_ngram_length = min_ngram_length
        self._wait = wait_between_tries

        if type(remove_duplicates) == bool:
            self._no_duplicates = remove_duplicates
        else:
            self._no_duplicates = tuple('<{}>'.format(x) for x in remove_duplicates)

        logger.debug('ARPA ignore set to {}'.format(self._ignore))
        logger.debug('ARPA url set to {}'.format(self._url))
        logger.debug('ARPA min_ngram_length set to {}'.format(self._min_ngram_length))
        logger.debug('ARPA no_duplicates set to {}'.format(self._no_duplicates))
        logger.debug('ARPA retries set to {}'.format(self._retries))

    def _remove_duplicates(self, entries):
        """
        Remove duplicates from the entries.

        A 'duplicate' is an entry with the same `LABEL_PROP` property value.

        If `self._no_duplicates == True`, choose the subject to keep any which way.

        If `self._no_duplicates` is a tuple (or a list), choose the kept subject
        by comparing its type to the types contained in the tuple. The lower the
        index of the type in the tuple, the higher the priority.

        `entries` is the ARPA service results as a JSON object.
        """

        res = entries
        if self._no_duplicates is True:
            labels = set()
            add = labels.add
            res = [x for x in res if not (x[LABEL_PROP] in labels
                # If the label is not in the labels set, add it to the set.
                # This works because set.add() returns None.
                or add(x[LABEL_PROP]))]

        elif self._no_duplicates:
            # self._no_duplicates is a tuple - prioritize types defined in it
            items = {}
            for x in res:
                x_label = x[LABEL_PROP].lower()
                # Get the types of the latest most preferrable entry that
                # had the same label as this one
                prev_match_types = items.get(x_label, {}).get('properties', {}).get(TYPE_PROP, [])
                # Get matches from the preferred types for the previously selected entry
                prev_pref = set(prev_match_types).intersection(set(self._no_duplicates))
                try:
                    # Find the priority of the previously selected entry
                    prev_idx = min([self._no_duplicates.index(t) for t in prev_pref])
                except ValueError:
                    # No previous entry or previous entry doesn't have a preferred type
                    prev_idx = float('inf')
                # Get matches in the preferred types for this entry
                pref = set(x['properties'][TYPE_PROP]).intersection(self._no_duplicates)
                try:
                    idx = min([self._no_duplicates.index(t) for t in pref])
                except ValueError:
                    # This one is not of a preferred type
                    idx = float('inf')

                if (not prev_match_types) or idx < prev_idx:
                    # There is no previous entry with this label or
                    # the current match has a higher priority preferred type
                    items[x_label] = x

            res = [x for x in res if x in items.values()]

        return res

    def _filter_results(self, results, get_len, get_label, skip_remove_duplicates=False):
        """
        Internal filter function used by `arpa.Arpa._filter`.
        """

        # Filter ignored results
        if self._ignore:
            results = [x for x in results if get_label(x) not in self._ignore]

        # Filter by minimum ngram length
        if self._min_ngram_length > 1:
            results = [x for x in results if get_len(x) >= self._min_ngram_length]

        # Remove duplicates unless requested to skip
        if skip_remove_duplicates:
            return results
        return self._remove_duplicates(results)

    def _filter(self, results, candidates=False):
        """
        Filter matches based on `self._ignore` and remove matches that are
        for ngrams with length less than `self.min_ngram_length`.

        Return the response with the ignored matches removed.

        `results` is the parsed ARPA service results.

        `candidates` is whether or not the results contain just the candidates.
        """

        if candidates:
            logger.debug('Filtering candidates')
            get_len = lambda x: len(x.split())
            get_label = lambda x: x.lower()
            # No use in removing literal duplicates
            skip_remove_duplicates = True
        else:
            logger.debug('Filtering results')
            get_len = lambda x: len(x['properties']['ngram'][0].split())
            get_label = lambda x: x[LABEL_PROP].lower()
            skip_remove_duplicates = False

        return self._filter_results(results, get_len, get_label, skip_remove_duplicates)

    def query(self, text, candidates=False):
        """
        Query the ARPA service and return the response results as JSON

        Results will be filtered if a filter was specified at init.

        `text` is the text used in the query.

        If `candidates` is set, query for candidates only.
        """

        logger.debug('Query ARPA at {} with text {}'.format(self._url, text))

        if not text:
            raise ValueError('Empty ARPA query text')

        url = self._url + ('?cgen' if candidates else '')

        # Query the ARPA service with the text
        data = {'text': text}

        res = post(url, data, retries=self._retries, wait=self._wait)

        return self._filter(res.get('results', []), candidates)

    def extract_uris(self, results):
        """
        Get the URIs from results.

        `results` is the results as returned by `arpa.query`.
        """
        return [URIRef(x['id']) for x in results]

    def get_distinct_mentions(self, results):
        """
        Get distinct mentions (i.e. matches) that yielded results.

        `results` is the results as returned by `arpa.query`.
        """
        return {m for ml in [p['matches'] for p in results] for m in ml}

    def get_uri_matches(self, text, *args, validator=None, **kwargs):
        """
        Query ARPA and return a dict with a list of uris of resources that match the text.

        Return a dict where 'results' has the list of uris, 'mentions' has the mentions
        that yielded results, and 'pre_validation_mentions' has mentions that yielded
        results before running the `validator`.

        `text` is the text to use in the query.

        `validator` is an object that implements a `validate` method that takes
        the results and `text` (and any other parameters passed to this method)
        as parameters, and returns a subset of the results.
        """

        logger.info('Getting URI matches: {}'.format(text))

        results = self.query(text)

        pre_validation_mentions = set()
        post_validation_mentions = set()

        if validator and results:
            logger.debug('Validating results: {}'.format(results))
            pre_validation_mentions = self.get_distinct_mentions(results)
            logger.info('Distinct mentions before validation: {} ({})'.format(len(pre_validation_mentions), pre_validation_mentions))
            results = validator.validate(results, text, *args, **kwargs)

        if results:
            logger.info('Found matches {}'.format(results))
            post_validation_mentions = self.get_distinct_mentions(results)
            logger.info('Distinct mentions: {} ({})'.format(len(post_validation_mentions), post_validation_mentions))
            results = self.extract_uris(results)
        else:
            logger.info('No matches found'.format(text))

        return {
            'results': results,
            'mentions': post_validation_mentions,
            'pre_validation_mentions': pre_validation_mentions
        }

    def get_candidates(self, text, *args, **kwargs):
        """
        Get the candidates from `text` that would be used by the ARPA service
        to query for matches.

        A dict is returned for compatibility with `arpa.get_uri_matches`.

        Return a dict where 'results' has the candidates as a list of rdflib Literals.
        """

        if not text:
            raise ValueError('Empty ARPA query text')

        res = self.query(text, candidates=True)

        logger.debug('Received candidates: {}'.format(res))

        result = {'results': [Literal(candidate) for candidate in res]}

        return result


class ArpaMimic(Arpa):
    """
    Class that behaves like `arpa.Arpa` except that it queries a SPARQL endpoint
    instead of an ARPA service.
    """

    def __init__(self, query_template, *args, **kwargs):
        """
        Initialize the ArpaMimic instance.

        `query_template` is a SPARQL query template like ARPA uses.
        """

        self.query_template = query_template

        super().__init__(*args, **kwargs)

    def query(self, text, url_params=''):
        """
        Query a SPARQL endpoint and return the response results as JSON mapped
        as if returned by ARPA.

        `text` is the text used in the query.

        `url_params` is any URL parameters to be added to the URL.
        """

        logger.debug('Querying {} with text {} using ArpaMimic'.format(self._url, text))

        if not text:
            raise ValueError('Empty query text')

        query = self.query_template.replace('<VALUES>', text)

        url = self._url + url_params

        # Query the endpoint with the text
        data = {'query': query}

        res = post(url, data, retries=self._retries, wait=self._wait)

        res = map_results(res)

        return self._filter(res.get('results', []))


class Bar:
    """
    Mock progress bar implementation
    """

    def __init__(self, n, *args, **kwargs):
        self.n = n

    def update(self, *args, **kwargs):
        pass


def get_bar(n, use_pyprind):
    """
    Get a progress bar.

    `n` is the number of iterations for the progress bar.

    If `use_pyprind` is true, try to return a `pyprind.ProgBar` instance. Otherwise,
    return a mock progress bar.
    """

    if use_pyprind:
        try:
            import pyprind
            logger.debug('Using pyprind progress bar')
            return pyprind.ProgBar(n)
        except ImportError:
            logger.warning('Tried to use pyprind progress bar but pyprind is not available')
            pass

    logger.debug('Using mock progress bar')
    return Bar(n)


def _get_subgraph(graph, source_prop, rdf_class=None):
    subgraph = Graph()

    if rdf_class:
        # Filter out subjects that are not of the given type
        for s in graph.subjects(RDF.type, rdf_class):
            subgraph += graph.triples((s, source_prop, None))
    else:
        subgraph += graph.triples((None, source_prop, None))

    return subgraph


def arpafy(graph, target_prop, arpa, source_prop=None, rdf_class=None,
            output_graph=None, preprocessor=None, validator=None,
            candidates_only=False, progress=None):
    """
    Link a property to resources using ARPA. Modify the graph in place,
    unless `output_graph` is given.

    Return a dict with the amount of processed triples (processed), the resulting graph (graph),
    match count (matches) and errors encountered (errors).

    `graph` is the graph to link (will be modified unless `output_graph` is defined.

    `target_prop` is the property name that is used for saving the link.

    `arpa` is the `arpa.Arpa` class instance.

    `source_prop` is the property that's value will be used when querying ARPA (if omitted, skos:prefLabel is used).

    If `rdf_class` is given, only go through instances of this type.

    `output_graph` is the graph to which the results should be added. If not given, the results will be added
    to the input `graph`.

    `preprocessor` is an optional function that processes the query text before it is used in the ARPA query.
    It receives whatever is the value of `source_prop` for the current subject, the current subject, and the graph.

    `validator` is an object with a `validate` method that takes the ARPA results, query text, and the processed
    subject as parameters, and returns a subset of the results (that have been validated based on the subject,
    graph and results). Optional.

    If `candidates_only` is set, get candidates (n-grams) only from ARPA.

    If `progress` is `True`, show a progress bar. Requires pyprind.
    """

    if source_prop is None:
        source_prop = SKOS['prefLabel']
    if output_graph is None:
        output_graph = graph
    if candidates_only:
        get_results = arpa.get_candidates
    else:
        get_results = arpa.get_uri_matches

    subgraph = _get_subgraph(graph, source_prop, rdf_class)

    triple_match_count = 0
    subject_match_count = 0
    pre_validation_mention_count = 0
    post_validation_mention_count = 0
    errors = []

    bar = get_bar(len(subgraph), progress)

    for s, o in subgraph.subject_objects():
        o = preprocessor(o, s, graph) if preprocessor else o
        try:
            result_dict = get_results(o, s, validator=validator)
        except (HTTPError, ValueError) as e:
            logger.exception('Error getting matches from ARPA')
            errors.append(e)
        else:
            results = result_dict['results']
            triple_match_count += len(results)
            pre_validation_mention_count += len(result_dict.get('pre_validation_mentions', []))
            if results:
                subject_match_count += 1
                post_validation_mention_count += len(result_dict.get('mentions', []))
                # Add each result as a value of the target property
                for result in results:
                    output_graph.add((s, target_prop, result))
        bar.update()

    res = {
        'graph': output_graph,
        'processed': len(subgraph),
        'matches': triple_match_count,
        'subjects_matched': subject_match_count,
        'pre_validation_mention_count': pre_validation_mention_count,
        'post_validation_mention_count': post_validation_mention_count,
        'errors': errors
    }

    logger.info('Processed {} triples, found {} matches from {} mentions'
                ' with {} total mentions ({} errors)'
                .format(res['processed'], res['matches'], res['post_validation_mention_count'],
                    res['pre_validation_mention_count'], len(res['errors'])))

    return res


def prune_candidates(graph, source_prop, pruner, rdf_class=None,
            output_graph=None, progress=None):
    """
    Prune undesired candidates.

    Return a dict with the amount of candidates left after pruning (result_count),
    and the resulting graph (graph).

    `graph` is the graph containing the candidates. Will be modified if `output_graph`
    is not given.

    `source_prop` is the property in the graph that has the candidates as its value.

    `pruner` is a function that receives a single candidate as string and returns
    a falsey value if the candidate should not be added to the output graph, and
    otherwise a string (the candidate, possibly modified) that should be added
    to the output graph.

    If `rdf_class` is given, only go through instances of this type.

    `output_graph` is the graph to which the results should be added.
    If not given, the results will be added to the input `graph`,
    and the old candidates removed.
    """

    logger.info('Pruning candidates')

    if output_graph is None:
        output_graph = graph

    subgraph = _get_subgraph(graph, source_prop, rdf_class)

    bar = get_bar(len(subgraph), progress)

    result_count = 0

    for s, o in subgraph.subject_objects():
        result = pruner(str(o))
        # Remove the original candidate
        output_graph.remove((s, source_prop, o))
        if result:
            result_count += 1
            # Add the pruned candidate to the output graph
            output_graph.add((s, source_prop, Literal(result)))
        bar.update()

    res = {
        'graph': output_graph,
        'result_count': result_count
    }

    logger.info('Candidate pruning complete')

    return res


def log_to_file(file_name, level):
    """
    Convenience function for setting up logging to file.

    `file_name` is the log file name.

    `level` is the log level name (string).
    """

    logger.setLevel(getattr(logging, level.upper()))
    handler = logging.FileHandler(file_name)
    handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
    logger.addHandler(handler)


def parse_args(args):
    """
    Parse command line arguments. See [Usage](#usage) (or the source code) for details.

    `args` is the list of command line arguments.
    """

    argparser = argparse.ArgumentParser(description="Link resources to an RDF graph with ARPA.",
            fromfile_prefix_chars="@")
    argparser.add_argument("input", help="Input rdf file")
    argparser.add_argument("output", help="Output file")
    argparser.add_argument("tprop", metavar="target_property", help="Target property for the matches")
    argparser.add_argument("arpa", help="ARPA service URL")
    argparser.add_argument("--fi", metavar="INPUT_FORMAT",
        help="Input file format (rdflib parser). Will be guessed if omitted.")
    argparser.add_argument("--fo", metavar="OUTPUT_FORMAT",
        help="Output file format (rdflib serializer). Default is turtle.", default="turtle")
    argparser.add_argument("-n", "--new_graph", action="store_true",
        help="""Add the ARPA results to a new graph instead of the original. The output file
        contains all the triples of the original graph by default. With this argument set
        the output file will contain only the results.""")
    argparser.add_argument("-c", "--candidates_only", action="store_true",
        help="""Get candidates (n-grams) only from ARPA.""")
    argparser.add_argument("--rdf_class", metavar="CLASS",
        help="Process only subjects of the given type (goes through all subjects by default).")
    argparser.add_argument("--prop", metavar="PROPERTY",
        help="Property that's value is to be used in matching. Default is skos:prefLabel.")
    argparser.add_argument("--ignore", nargs="*", metavar="TERM",
        help="Terms that should be ignored even if matched")
    argparser.add_argument("--min_ngram", default=1, metavar="N", type=int,
        help="The minimum ngram length that is considered a match. Default is 1.")
    argparser.add_argument("--no_duplicates", nargs="*", default=False, metavar="TYPE",
        help="""Remove duplicate matches based on the 'label' returned by the ARPA service.
        Here 'duplicate' means a subject with the same label as another subject in
        the same result set.
        A list of types can be given with this argument. If given, prioritize matches
        based on it - the first given type will get the highest priority and so on.
        Note that the response from the service has to include a 'type' variable
        for this to work.""")
    argparser.add_argument("-r", "--retries", default=0, metavar="N", type=int,
        help="The amount of retries per query if a HTTP error is received. Default is 0.")
    argparser.add_argument("-w", "--wait", default=1, metavar="N", type=int,
        help="""The number of seconds to wait between retries. Only has an effect if number
        of retries is set. Default is 1 second.""")
    argparser.add_argument("--log_level", default="INFO",
        choices=["NOTSET", "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Logging level, default is INFO.")
    argparser.add_argument("--log_file", default="arpa_linker.log",
        help="The log file. Default is arpa_linker.log.")

    args = argparser.parse_args(args)

    if not args.fi:
        args.fi = guess_format(args.input)

    if args.prop:
        args.prop = URIRef(args.prop)

    if args.rdf_class:
        args.rdf_class = URIRef(args.rdf_class)

    args.tprop = URIRef(args.tprop)

    if args.no_duplicates == []:
        args.no_duplicates = True

    return args


def combine_values(values):
    """Combine values into a single string"""

    values = [str(o).replace('"', '\\"') for o in values]
    return '"' + '" "'.join(values) + '"'


def combine_candidates(graph, prop, output_graph=None, rdf_class=None, progress=None):
    """
    Combine each subject's candidates into a single string.

    Return the resulting graph.

    `graph` is the graph containing the candidates. Will be modified if `output_graph`
    is not given.

    `prop` is the URIRef of the property containing the candidates.

    `output_graph` is the graph to which the results should be added.
    If not given, `graph` will be modified.

    If `rdf_class` is given, only go through instances of this type.

    If `progress` is set, display a progress bar.
    """

    subgraph = _get_subgraph(graph, prop, rdf_class)

    logger.info('Combining candidates')

    if output_graph is None:
        output_graph = graph

    subjects = subgraph.subjects()
    bar = get_bar(len(subgraph), progress)

    for s in subjects:
        combined = combine_values(subgraph.objects(s))
        # Remove the original candidate
        output_graph.remove((s, None, None))
        output_graph.add((s, prop, Literal(combined)))
        bar.update()

    logger.info('Candidates combined succesfully')

    return output_graph


def process_graph(graph, target_prop=None, arpa=None, new_graph=False, prune=False, join_candidates=False,
        run_arpafy=True, source_prop=None, rdf_class=None, pruner=None, progress=None, **kwargs):
    """
    Convenience function for running different tasks related to linking.

    `graph` is the graph to be processed.

    `target_prop` is the property name that is used for saving the link.
    Used only if `run_arpafy` is True.

    `arpa` is the `arpa.Arpa` class instance.
    Used only if `run_arpafy` is True.

    If `new_graph` is set, use a new empty graph for adding the results.

    If `prune` is set, prune candidates using `arpa.prune_candidates`.

    If `join_candidates` is set, combine candidates into a single value using
    `arpa.combine_candidates`.

    Setting `run_arpafy` to False will skip running `arpa.arpafy`.
    Useful with `join_candidates`.

    `source_prop` is the property URI that contains the values to be processed.

    For `pruner` see `arpa.prune_candidates`.

    If `progress` is `True`, show a progress bar. Requires pyprind.

    All other arguments are passed to `arpa.arpafy` (if run).

    Return the results dict as returned by `arpa.arpafy`.
    """

    if new_graph:
        logger.debug('Output to new graph')
        output_graph = Graph()
        output_graph.namespace_manager = graph.namespace_manager
    else:
        output_graph = graph

    logger.info('Begin processing')
    start_time = time.monotonic()

    if prune:
        logger.info('Prune candidates')
        res = prune_candidates(graph, source_prop, pruner,
                rdf_class=rdf_class, output_graph=output_graph,
                progress=progress)
        graph = res['graph']

    if join_candidates:
        logger.debug('Combine candidates')
        output_graph = combine_candidates(graph, source_prop,
                output_graph=output_graph, rdf_class=rdf_class,
                progress=progress)
        graph = output_graph
        res = {'graph': output_graph}

    if run_arpafy:
        logger.info('Start arpafy')
        res = arpafy(graph, target_prop=target_prop, arpa=arpa, source_prop=source_prop, rdf_class=rdf_class,
                output_graph=output_graph, progress=progress, **kwargs)

    end_time = time.monotonic()
    logger.info('Processing complete, runtime {}'.
            format(timedelta(seconds=(end_time - start_time))))

    return res


def process(input_file, input_format, output_file, output_format, *args,
        validator_class=None, **kwargs):
    """
    Parse the given input file, run `arpa.arpafy`, and serialize the resulting
    graph on disk.

    `input_file` is the name of the rdf file to be parsed.

    `input_format` is the input file format.

    `output_file` is the output file name.

    `output_format` is the output file format.

    `validator_class` is class that takes the input graph as parameter, and implements
    a `validate` method. See `arpa.arpafy` for more information.
    This overrides any validator object given as the `arpa.arpafy` `validator` parameter.

    All other arguments are passed to `arpa.process_graph`.

    Return the results dict as returned by `arpa.arpafy`.
    """

    g = Graph()
    logger.info('Parsing file {}'.format(input_file))
    g.parse(input_file, format=input_format)
    logger.info('Parsing complete')

    if validator_class:
        kwargs['validator'] = validator_class(g)

    res = process_graph(g, *args, **kwargs)

    output_graph = res['graph']

    logger.info('Serializing graph as {}'.format(output_file))
    output_graph.serialize(destination=output_file, format=output_format)
    logger.info('Serialization complete')

    return res


def main(args):
    """
    Main function for running via the command line.

    `args` is the list of command line arguments.
    """

    args = parse_args(args)

    log_to_file(args.log_file, args.log_level)

    arpa = Arpa(args.arpa, args.no_duplicates, args.min_ngram, args.ignore, args.retries)

    # Query the ARPA service, add the matches and serialize graph to disk
    process(args.input, args.fi, args.output, args.fo, target_prop=args.tprop,
            arpa=arpa, source_prop=args.prop, rdf_class=args.rdf_class,
            new_graph=args.new_graph, progress=True, candidates_only=args.candidates_only)

    logging.shutdown()


if __name__ == '__main__':
    main(sys.argv[1:])
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="arpa.LABEL_PROP" class="name">var <span class="ident">LABEL_PROP</span></p>
      
  
    <div class="desc"><p>The name of the property containing the label of the match in the ARPA results.</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="arpa.TYPE_PROP" class="name">var <span class="ident">TYPE_PROP</span></p>
      
  
    <div class="desc"><p>The name of the property containing the type of the match in the ARPA results-&gt;properties.
Only needed for prioritized duplicate removal.</p></div>
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="arpa.arpafy">
    <p>def <span class="ident">arpafy</span>(</p><p>graph, target_prop, arpa, source_prop=None, rdf_class=None, output_graph=None, preprocessor=None, validator=None, candidates_only=False, progress=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Link a property to resources using ARPA. Modify the graph in place,
unless <code>output_graph</code> is given.</p>
<p>Return a dict with the amount of processed triples (processed), the resulting graph (graph),
match count (matches) and errors encountered (errors).</p>
<p><code>graph</code> is the graph to link (will be modified unless <code>output_graph</code> is defined.</p>
<p><code>target_prop</code> is the property name that is used for saving the link.</p>
<p><code>arpa</code> is the <a href="#arpa.Arpa"><code>Arpa</code></a> class instance.</p>
<p><code>source_prop</code> is the property that's value will be used when querying ARPA (if omitted, skos:prefLabel is used).</p>
<p>If <code>rdf_class</code> is given, only go through instances of this type.</p>
<p><code>output_graph</code> is the graph to which the results should be added. If not given, the results will be added
to the input <code>graph</code>.</p>
<p><code>preprocessor</code> is an optional function that processes the query text before it is used in the ARPA query.
It receives whatever is the value of <code>source_prop</code> for the current subject, the current subject, and the graph.</p>
<p><code>validator</code> is an object with a <code>validate</code> method that takes the ARPA results, query text, and the processed
subject as parameters, and returns a subset of the results (that have been validated based on the subject,
graph and results). Optional.</p>
<p>If <code>candidates_only</code> is set, get candidates (n-grams) only from ARPA.</p>
<p>If <code>progress</code> is <code>True</code>, show a progress bar. Requires pyprind.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.arpafy', this);">Show source &equiv;</a></p>
  <div id="source-arpa.arpafy" class="source">
    <pre><code>def arpafy(graph, target_prop, arpa, source_prop=None, rdf_class=None,
            output_graph=None, preprocessor=None, validator=None,
            candidates_only=False, progress=None):
    """
    Link a property to resources using ARPA. Modify the graph in place,
    unless `output_graph` is given.

    Return a dict with the amount of processed triples (processed), the resulting graph (graph),
    match count (matches) and errors encountered (errors).

    `graph` is the graph to link (will be modified unless `output_graph` is defined.

    `target_prop` is the property name that is used for saving the link.

    `arpa` is the `arpa.Arpa` class instance.

    `source_prop` is the property that's value will be used when querying ARPA (if omitted, skos:prefLabel is used).

    If `rdf_class` is given, only go through instances of this type.

    `output_graph` is the graph to which the results should be added. If not given, the results will be added
    to the input `graph`.

    `preprocessor` is an optional function that processes the query text before it is used in the ARPA query.
    It receives whatever is the value of `source_prop` for the current subject, the current subject, and the graph.

    `validator` is an object with a `validate` method that takes the ARPA results, query text, and the processed
    subject as parameters, and returns a subset of the results (that have been validated based on the subject,
    graph and results). Optional.

    If `candidates_only` is set, get candidates (n-grams) only from ARPA.

    If `progress` is `True`, show a progress bar. Requires pyprind.
    """

    if source_prop is None:
        source_prop = SKOS['prefLabel']
    if output_graph is None:
        output_graph = graph
    if candidates_only:
        get_results = arpa.get_candidates
    else:
        get_results = arpa.get_uri_matches

    subgraph = _get_subgraph(graph, source_prop, rdf_class)

    triple_match_count = 0
    subject_match_count = 0
    pre_validation_mention_count = 0
    post_validation_mention_count = 0
    errors = []

    bar = get_bar(len(subgraph), progress)

    for s, o in subgraph.subject_objects():
        o = preprocessor(o, s, graph) if preprocessor else o
        try:
            result_dict = get_results(o, s, validator=validator)
        except (HTTPError, ValueError) as e:
            logger.exception('Error getting matches from ARPA')
            errors.append(e)
        else:
            results = result_dict['results']
            triple_match_count += len(results)
            pre_validation_mention_count += len(result_dict.get('pre_validation_mentions', []))
            if results:
                subject_match_count += 1
                post_validation_mention_count += len(result_dict.get('mentions', []))
                # Add each result as a value of the target property
                for result in results:
                    output_graph.add((s, target_prop, result))
        bar.update()

    res = {
        'graph': output_graph,
        'processed': len(subgraph),
        'matches': triple_match_count,
        'subjects_matched': subject_match_count,
        'pre_validation_mention_count': pre_validation_mention_count,
        'post_validation_mention_count': post_validation_mention_count,
        'errors': errors
    }

    logger.info('Processed {} triples, found {} matches from {} mentions'
                ' with {} total mentions ({} errors)'
                .format(res['processed'], res['matches'], res['post_validation_mention_count'],
                    res['pre_validation_mention_count'], len(res['errors'])))

    return res
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.combine_candidates">
    <p>def <span class="ident">combine_candidates</span>(</p><p>graph, prop, output_graph=None, rdf_class=None, progress=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Combine each subject's candidates into a single string.</p>
<p>Return the resulting graph.</p>
<p><code>graph</code> is the graph containing the candidates. Will be modified if <code>output_graph</code>
is not given.</p>
<p><code>prop</code> is the URIRef of the property containing the candidates.</p>
<p><code>output_graph</code> is the graph to which the results should be added.
If not given, <code>graph</code> will be modified.</p>
<p>If <code>rdf_class</code> is given, only go through instances of this type.</p>
<p>If <code>progress</code> is set, display a progress bar.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.combine_candidates', this);">Show source &equiv;</a></p>
  <div id="source-arpa.combine_candidates" class="source">
    <pre><code>def combine_candidates(graph, prop, output_graph=None, rdf_class=None, progress=None):
    """
    Combine each subject's candidates into a single string.

    Return the resulting graph.

    `graph` is the graph containing the candidates. Will be modified if `output_graph`
    is not given.

    `prop` is the URIRef of the property containing the candidates.

    `output_graph` is the graph to which the results should be added.
    If not given, `graph` will be modified.

    If `rdf_class` is given, only go through instances of this type.

    If `progress` is set, display a progress bar.
    """

    subgraph = _get_subgraph(graph, prop, rdf_class)

    logger.info('Combining candidates')

    if output_graph is None:
        output_graph = graph

    subjects = subgraph.subjects()
    bar = get_bar(len(subgraph), progress)

    for s in subjects:
        combined = combine_values(subgraph.objects(s))
        # Remove the original candidate
        output_graph.remove((s, None, None))
        output_graph.add((s, prop, Literal(combined)))
        bar.update()

    logger.info('Candidates combined succesfully')

    return output_graph
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.log_to_file">
    <p>def <span class="ident">log_to_file</span>(</p><p>file_name, level)</p>
    </div>
    

    
  
    <div class="desc"><p>Convenience function for setting up logging to file.</p>
<p><code>file_name</code> is the log file name.</p>
<p><code>level</code> is the log level name (string).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.log_to_file', this);">Show source &equiv;</a></p>
  <div id="source-arpa.log_to_file" class="source">
    <pre><code>def log_to_file(file_name, level):
    """
    Convenience function for setting up logging to file.

    `file_name` is the log file name.

    `level` is the log level name (string).
    """

    logger.setLevel(getattr(logging, level.upper()))
    handler = logging.FileHandler(file_name)
    handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
    logger.addHandler(handler)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.main">
    <p>def <span class="ident">main</span>(</p><p>args)</p>
    </div>
    

    
  
    <div class="desc"><p>Main function for running via the command line.</p>
<p><code>args</code> is the list of command line arguments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.main', this);">Show source &equiv;</a></p>
  <div id="source-arpa.main" class="source">
    <pre><code>def main(args):
    """
    Main function for running via the command line.

    `args` is the list of command line arguments.
    """

    args = parse_args(args)

    log_to_file(args.log_file, args.log_level)

    arpa = Arpa(args.arpa, args.no_duplicates, args.min_ngram, args.ignore, args.retries)

    # Query the ARPA service, add the matches and serialize graph to disk
    process(args.input, args.fi, args.output, args.fo, target_prop=args.tprop,
            arpa=arpa, source_prop=args.prop, rdf_class=args.rdf_class,
            new_graph=args.new_graph, progress=True, candidates_only=args.candidates_only)

    logging.shutdown()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.map_results">
    <p>def <span class="ident">map_results</span>(</p><p>results)</p>
    </div>
    

    
  
    <div class="desc"><p>Map general SPARQL results to the format ARPA returns.</p>
<p>Return the mapped results.</p>
<p><code>results</code> is the SPARQL result as a dict. Each row has to include an 'id' variable.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.map_results', this);">Show source &equiv;</a></p>
  <div id="source-arpa.map_results" class="source">
    <pre><code>def map_results(results):
    """
    Map general SPARQL results to the format ARPA returns.

    Return the mapped results.

    `results` is the SPARQL result as a dict. Each row has to include an 'id' variable.
    """

    logger.debug('Mapping results {} to ARPA format'.format(results))

    res = []
    for obj in results['results']['bindings']:
        o_id = obj['id']['value']

        idx = next((index for (index, d) in enumerate(res) if d['id'] == o_id), None)
        if idx is None:
            props = {key: [_get_value(value)] for key, value in obj.items()}
            o = {
                'id': o_id,
                'label': obj.get('label', {}).get('value', ''),
                'matches': [obj.get('ngram', {}).get('value', '')],
                'properties': props
            }
            res.append(o)
        else:
            o = res[idx]
            ngram = obj.get('ngram', {}).get('value', '')
            if ngram not in o['matches']:
                o['matches'].append(ngram)
            for k, v in obj.items():
                p = o.get('properties').get(k, None)
                if p:
                    p.append(_get_value(v))
                else:
                    o['properties'][k] = [_get_value(v)]

    res = {'results': res}

    logger.debug('Mapped to: {}'.format(res))

    return res
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.parse_args">
    <p>def <span class="ident">parse_args</span>(</p><p>args)</p>
    </div>
    

    
  
    <div class="desc"><p>Parse command line arguments. See <a href="#usage">Usage</a> (or the source code) for details.</p>
<p><code>args</code> is the list of command line arguments.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.parse_args', this);">Show source &equiv;</a></p>
  <div id="source-arpa.parse_args" class="source">
    <pre><code>def parse_args(args):
    """
    Parse command line arguments. See [Usage](#usage) (or the source code) for details.

    `args` is the list of command line arguments.
    """

    argparser = argparse.ArgumentParser(description="Link resources to an RDF graph with ARPA.",
            fromfile_prefix_chars="@")
    argparser.add_argument("input", help="Input rdf file")
    argparser.add_argument("output", help="Output file")
    argparser.add_argument("tprop", metavar="target_property", help="Target property for the matches")
    argparser.add_argument("arpa", help="ARPA service URL")
    argparser.add_argument("--fi", metavar="INPUT_FORMAT",
        help="Input file format (rdflib parser). Will be guessed if omitted.")
    argparser.add_argument("--fo", metavar="OUTPUT_FORMAT",
        help="Output file format (rdflib serializer). Default is turtle.", default="turtle")
    argparser.add_argument("-n", "--new_graph", action="store_true",
        help="""Add the ARPA results to a new graph instead of the original. The output file
        contains all the triples of the original graph by default. With this argument set
        the output file will contain only the results.""")
    argparser.add_argument("-c", "--candidates_only", action="store_true",
        help="""Get candidates (n-grams) only from ARPA.""")
    argparser.add_argument("--rdf_class", metavar="CLASS",
        help="Process only subjects of the given type (goes through all subjects by default).")
    argparser.add_argument("--prop", metavar="PROPERTY",
        help="Property that's value is to be used in matching. Default is skos:prefLabel.")
    argparser.add_argument("--ignore", nargs="*", metavar="TERM",
        help="Terms that should be ignored even if matched")
    argparser.add_argument("--min_ngram", default=1, metavar="N", type=int,
        help="The minimum ngram length that is considered a match. Default is 1.")
    argparser.add_argument("--no_duplicates", nargs="*", default=False, metavar="TYPE",
        help="""Remove duplicate matches based on the 'label' returned by the ARPA service.
        Here 'duplicate' means a subject with the same label as another subject in
        the same result set.
        A list of types can be given with this argument. If given, prioritize matches
        based on it - the first given type will get the highest priority and so on.
        Note that the response from the service has to include a 'type' variable
        for this to work.""")
    argparser.add_argument("-r", "--retries", default=0, metavar="N", type=int,
        help="The amount of retries per query if a HTTP error is received. Default is 0.")
    argparser.add_argument("-w", "--wait", default=1, metavar="N", type=int,
        help="""The number of seconds to wait between retries. Only has an effect if number
        of retries is set. Default is 1 second.""")
    argparser.add_argument("--log_level", default="INFO",
        choices=["NOTSET", "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Logging level, default is INFO.")
    argparser.add_argument("--log_file", default="arpa_linker.log",
        help="The log file. Default is arpa_linker.log.")

    args = argparser.parse_args(args)

    if not args.fi:
        args.fi = guess_format(args.input)

    if args.prop:
        args.prop = URIRef(args.prop)

    if args.rdf_class:
        args.rdf_class = URIRef(args.rdf_class)

    args.tprop = URIRef(args.tprop)

    if args.no_duplicates == []:
        args.no_duplicates = True

    return args
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.post">
    <p>def <span class="ident">post</span>(</p><p>url, data, retries=0, wait=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Send a post request to the given URL with the given data, expecting a JSON response.
Throws a HTTPError if the request fails (after retries, if any) or if JSON
parsing fails.</p>
<p><code>url</code> is the URL to send the request to.</p>
<p><code>data</code> is a dict containing the data to send to the URL.</p>
<p><code>retries</code> is the number of retries to attempt if the request fails. Optional.</p>
<p><code>wait</code> is the number of seconds to wait between retries. Optional, default is 1 second.
Has no effect if <code>retries</code> is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.post', this);">Show source &equiv;</a></p>
  <div id="source-arpa.post" class="source">
    <pre><code>def post(url, data, retries=0, wait=1):
    """
    Send a post request to the given URL with the given data, expecting a JSON response.
    Throws a HTTPError if the request fails (after retries, if any) or if JSON
    parsing fails.

    `url` is the URL to send the request to.

    `data` is a dict containing the data to send to the URL.

    `retries` is the number of retries to attempt if the request fails. Optional.

    `wait` is the number of seconds to wait between retries. Optional, default is 1 second.
    Has no effect if `retries` is not set.
    """

    if retries < 0:
        raise ValueError('Invalid amount of retries: {}'.format(retries))
    if wait < 0:
        raise ValueError('Invalid retry wait time: {}'.format(wait))

    tries = retries + 1

    while tries:
        logger.debug('Sending request to {} with data: {}'.format(url, data))
        res = requests.post(url, data)
        try:
            res.raise_for_status()
            res = res.json()
        except (HTTPError, ValueError) as e:
            tries -= 1
            if tries:
                logger.warning('Received error ({}) from {} with request data: {}.'
                        .format(e, url, data))
                logger.warning('Waiting {} seconds before retrying'.format(wait))
                time.sleep(wait)
                continue
            elif retries:
                logger.warning('Error {}, out of retries.'.format(e))
            raise HTTPError('Error ({}) from {} with request data: {}.'.format(e, url, data))
        else:
            # Success
            logger.debug('Success, received: {}'.format(res))
            return res
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.process">
    <p>def <span class="ident">process</span>(</p><p>input_file, input_format, output_file, output_format, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Parse the given input file, run <a href="#arpa.arpafy"><code>arpafy</code></a>, and serialize the resulting
graph on disk.</p>
<p><code>input_file</code> is the name of the rdf file to be parsed.</p>
<p><code>input_format</code> is the input file format.</p>
<p><code>output_file</code> is the output file name.</p>
<p><code>output_format</code> is the output file format.</p>
<p><code>validator_class</code> is class that takes the input graph as parameter, and implements
a <code>validate</code> method. See <a href="#arpa.arpafy"><code>arpafy</code></a> for more information.
This overrides any validator object given as the <a href="#arpa.arpafy"><code>arpafy</code></a> <code>validator</code> parameter.</p>
<p>All other arguments are passed to <a href="#arpa.process_graph"><code>process_graph</code></a>.</p>
<p>Return the results dict as returned by <a href="#arpa.arpafy"><code>arpafy</code></a>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.process', this);">Show source &equiv;</a></p>
  <div id="source-arpa.process" class="source">
    <pre><code>def process(input_file, input_format, output_file, output_format, *args,
        validator_class=None, **kwargs):
    """
    Parse the given input file, run `arpa.arpafy`, and serialize the resulting
    graph on disk.

    `input_file` is the name of the rdf file to be parsed.

    `input_format` is the input file format.

    `output_file` is the output file name.

    `output_format` is the output file format.

    `validator_class` is class that takes the input graph as parameter, and implements
    a `validate` method. See `arpa.arpafy` for more information.
    This overrides any validator object given as the `arpa.arpafy` `validator` parameter.

    All other arguments are passed to `arpa.process_graph`.

    Return the results dict as returned by `arpa.arpafy`.
    """

    g = Graph()
    logger.info('Parsing file {}'.format(input_file))
    g.parse(input_file, format=input_format)
    logger.info('Parsing complete')

    if validator_class:
        kwargs['validator'] = validator_class(g)

    res = process_graph(g, *args, **kwargs)

    output_graph = res['graph']

    logger.info('Serializing graph as {}'.format(output_file))
    output_graph.serialize(destination=output_file, format=output_format)
    logger.info('Serialization complete')

    return res
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.process_graph">
    <p>def <span class="ident">process_graph</span>(</p><p>graph, target_prop=None, arpa=None, new_graph=False, prune=False, join_candidates=False, run_arpafy=True, source_prop=None, rdf_class=None, pruner=None, progress=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Convenience function for running different tasks related to linking.</p>
<p><code>graph</code> is the graph to be processed.</p>
<p><code>target_prop</code> is the property name that is used for saving the link.
Used only if <code>run_arpafy</code> is True.</p>
<p><code>arpa</code> is the <a href="#arpa.Arpa"><code>Arpa</code></a> class instance.
Used only if <code>run_arpafy</code> is True.</p>
<p>If <code>new_graph</code> is set, use a new empty graph for adding the results.</p>
<p>If <code>prune</code> is set, prune candidates using <a href="#arpa.prune_candidates"><code>prune_candidates</code></a>.</p>
<p>If <code>join_candidates</code> is set, combine candidates into a single value using
<a href="#arpa.combine_candidates"><code>combine_candidates</code></a>.</p>
<p>Setting <code>run_arpafy</code> to False will skip running <a href="#arpa.arpafy"><code>arpafy</code></a>.
Useful with <code>join_candidates</code>.</p>
<p><code>source_prop</code> is the property URI that contains the values to be processed.</p>
<p>For <code>pruner</code> see <a href="#arpa.prune_candidates"><code>prune_candidates</code></a>.</p>
<p>If <code>progress</code> is <code>True</code>, show a progress bar. Requires pyprind.</p>
<p>All other arguments are passed to <a href="#arpa.arpafy"><code>arpafy</code></a> (if run).</p>
<p>Return the results dict as returned by <a href="#arpa.arpafy"><code>arpafy</code></a>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.process_graph', this);">Show source &equiv;</a></p>
  <div id="source-arpa.process_graph" class="source">
    <pre><code>def process_graph(graph, target_prop=None, arpa=None, new_graph=False, prune=False, join_candidates=False,
        run_arpafy=True, source_prop=None, rdf_class=None, pruner=None, progress=None, **kwargs):
    """
    Convenience function for running different tasks related to linking.

    `graph` is the graph to be processed.

    `target_prop` is the property name that is used for saving the link.
    Used only if `run_arpafy` is True.

    `arpa` is the `arpa.Arpa` class instance.
    Used only if `run_arpafy` is True.

    If `new_graph` is set, use a new empty graph for adding the results.

    If `prune` is set, prune candidates using `arpa.prune_candidates`.

    If `join_candidates` is set, combine candidates into a single value using
    `arpa.combine_candidates`.

    Setting `run_arpafy` to False will skip running `arpa.arpafy`.
    Useful with `join_candidates`.

    `source_prop` is the property URI that contains the values to be processed.

    For `pruner` see `arpa.prune_candidates`.

    If `progress` is `True`, show a progress bar. Requires pyprind.

    All other arguments are passed to `arpa.arpafy` (if run).

    Return the results dict as returned by `arpa.arpafy`.
    """

    if new_graph:
        logger.debug('Output to new graph')
        output_graph = Graph()
        output_graph.namespace_manager = graph.namespace_manager
    else:
        output_graph = graph

    logger.info('Begin processing')
    start_time = time.monotonic()

    if prune:
        logger.info('Prune candidates')
        res = prune_candidates(graph, source_prop, pruner,
                rdf_class=rdf_class, output_graph=output_graph,
                progress=progress)
        graph = res['graph']

    if join_candidates:
        logger.debug('Combine candidates')
        output_graph = combine_candidates(graph, source_prop,
                output_graph=output_graph, rdf_class=rdf_class,
                progress=progress)
        graph = output_graph
        res = {'graph': output_graph}

    if run_arpafy:
        logger.info('Start arpafy')
        res = arpafy(graph, target_prop=target_prop, arpa=arpa, source_prop=source_prop, rdf_class=rdf_class,
                output_graph=output_graph, progress=progress, **kwargs)

    end_time = time.monotonic()
    logger.info('Processing complete, runtime {}'.
            format(timedelta(seconds=(end_time - start_time))))

    return res
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="arpa.prune_candidates">
    <p>def <span class="ident">prune_candidates</span>(</p><p>graph, source_prop, pruner, rdf_class=None, output_graph=None, progress=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Prune undesired candidates.</p>
<p>Return a dict with the amount of candidates left after pruning (result_count),
and the resulting graph (graph).</p>
<p><code>graph</code> is the graph containing the candidates. Will be modified if <code>output_graph</code>
is not given.</p>
<p><code>source_prop</code> is the property in the graph that has the candidates as its value.</p>
<p><code>pruner</code> is a function that receives a single candidate as string and returns
a falsey value if the candidate should not be added to the output graph, and
otherwise a string (the candidate, possibly modified) that should be added
to the output graph.</p>
<p>If <code>rdf_class</code> is given, only go through instances of this type.</p>
<p><code>output_graph</code> is the graph to which the results should be added.
If not given, the results will be added to the input <code>graph</code>,
and the old candidates removed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.prune_candidates', this);">Show source &equiv;</a></p>
  <div id="source-arpa.prune_candidates" class="source">
    <pre><code>def prune_candidates(graph, source_prop, pruner, rdf_class=None,
            output_graph=None, progress=None):
    """
    Prune undesired candidates.

    Return a dict with the amount of candidates left after pruning (result_count),
    and the resulting graph (graph).

    `graph` is the graph containing the candidates. Will be modified if `output_graph`
    is not given.

    `source_prop` is the property in the graph that has the candidates as its value.

    `pruner` is a function that receives a single candidate as string and returns
    a falsey value if the candidate should not be added to the output graph, and
    otherwise a string (the candidate, possibly modified) that should be added
    to the output graph.

    If `rdf_class` is given, only go through instances of this type.

    `output_graph` is the graph to which the results should be added.
    If not given, the results will be added to the input `graph`,
    and the old candidates removed.
    """

    logger.info('Pruning candidates')

    if output_graph is None:
        output_graph = graph

    subgraph = _get_subgraph(graph, source_prop, rdf_class)

    bar = get_bar(len(subgraph), progress)

    result_count = 0

    for s, o in subgraph.subject_objects():
        result = pruner(str(o))
        # Remove the original candidate
        output_graph.remove((s, source_prop, o))
        if result:
            result_count += 1
            # Add the pruned candidate to the output graph
            output_graph.add((s, source_prop, Literal(result)))
        bar.update()

    res = {
        'graph': output_graph,
        'result_count': result_count
    }

    logger.info('Candidate pruning complete')

    return res
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="arpa.Arpa" class="name">class <span class="ident">Arpa</span></p>
      
  
    <div class="desc"><p>Class representing the ARPA service</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.Arpa', this);">Show source &equiv;</a></p>
  <div id="source-arpa.Arpa" class="source">
    <pre><code>class Arpa:
    """Class representing the ARPA service"""

    def __init__(self, url, remove_duplicates=False, min_ngram_length=1, ignore=None,
            retries=0, wait_between_tries=1):
        """
        Initialize the Arpa service object.

        `url` is the ARPA service url.

        If `remove_duplicates` is `True`, choose only one subject out of all the
        matched subjects that have the same label (arbitrarily).
        If, instead, the value is a list or a tuple, assume that it represents
        a list of class names and prefer those classes when choosing
        the subject. The ARPA results must include a property (`arpa.TYPE_PROP`)
        that has the class of the match as the value. Optional.

        `min_ngram_length` is the minimum ngram match length that will be included when
        returning the query results. Optional.

        `ignore` is a list of matches that should be removed from the results (case insensitive).
        Optional.

        `retries` is the number of retries per query. Optional.

        `wait_between_tries` is the amount of times in seconds to wait between retries.
        Optional, default is 1 second. Has no effect if `retries` is not set.
        """

        logger.debug('Initialize Arpa instance')

        if retries < 0:
            raise ValueError('Number of retries has to be a non-negative number, got {}'
                    .format(retries))
        if wait_between_tries < 0:
            raise ValueError('Retry wait time has to be a non-negative number, got {}'
                    .format(wait_between_tries))

        self._retries = retries

        self._url = url
        self._ignore = [s.lower() for s in ignore or []]
        self._min_ngram_length = min_ngram_length
        self._wait = wait_between_tries

        if type(remove_duplicates) == bool:
            self._no_duplicates = remove_duplicates
        else:
            self._no_duplicates = tuple('<{}>'.format(x) for x in remove_duplicates)

        logger.debug('ARPA ignore set to {}'.format(self._ignore))
        logger.debug('ARPA url set to {}'.format(self._url))
        logger.debug('ARPA min_ngram_length set to {}'.format(self._min_ngram_length))
        logger.debug('ARPA no_duplicates set to {}'.format(self._no_duplicates))
        logger.debug('ARPA retries set to {}'.format(self._retries))

    def _remove_duplicates(self, entries):
        """
        Remove duplicates from the entries.

        A 'duplicate' is an entry with the same `LABEL_PROP` property value.

        If `self._no_duplicates == True`, choose the subject to keep any which way.

        If `self._no_duplicates` is a tuple (or a list), choose the kept subject
        by comparing its type to the types contained in the tuple. The lower the
        index of the type in the tuple, the higher the priority.

        `entries` is the ARPA service results as a JSON object.
        """

        res = entries
        if self._no_duplicates is True:
            labels = set()
            add = labels.add
            res = [x for x in res if not (x[LABEL_PROP] in labels
                # If the label is not in the labels set, add it to the set.
                # This works because set.add() returns None.
                or add(x[LABEL_PROP]))]

        elif self._no_duplicates:
            # self._no_duplicates is a tuple - prioritize types defined in it
            items = {}
            for x in res:
                x_label = x[LABEL_PROP].lower()
                # Get the types of the latest most preferrable entry that
                # had the same label as this one
                prev_match_types = items.get(x_label, {}).get('properties', {}).get(TYPE_PROP, [])
                # Get matches from the preferred types for the previously selected entry
                prev_pref = set(prev_match_types).intersection(set(self._no_duplicates))
                try:
                    # Find the priority of the previously selected entry
                    prev_idx = min([self._no_duplicates.index(t) for t in prev_pref])
                except ValueError:
                    # No previous entry or previous entry doesn't have a preferred type
                    prev_idx = float('inf')
                # Get matches in the preferred types for this entry
                pref = set(x['properties'][TYPE_PROP]).intersection(self._no_duplicates)
                try:
                    idx = min([self._no_duplicates.index(t) for t in pref])
                except ValueError:
                    # This one is not of a preferred type
                    idx = float('inf')

                if (not prev_match_types) or idx < prev_idx:
                    # There is no previous entry with this label or
                    # the current match has a higher priority preferred type
                    items[x_label] = x

            res = [x for x in res if x in items.values()]

        return res

    def _filter_results(self, results, get_len, get_label, skip_remove_duplicates=False):
        """
        Internal filter function used by `arpa.Arpa._filter`.
        """

        # Filter ignored results
        if self._ignore:
            results = [x for x in results if get_label(x) not in self._ignore]

        # Filter by minimum ngram length
        if self._min_ngram_length > 1:
            results = [x for x in results if get_len(x) >= self._min_ngram_length]

        # Remove duplicates unless requested to skip
        if skip_remove_duplicates:
            return results
        return self._remove_duplicates(results)

    def _filter(self, results, candidates=False):
        """
        Filter matches based on `self._ignore` and remove matches that are
        for ngrams with length less than `self.min_ngram_length`.

        Return the response with the ignored matches removed.

        `results` is the parsed ARPA service results.

        `candidates` is whether or not the results contain just the candidates.
        """

        if candidates:
            logger.debug('Filtering candidates')
            get_len = lambda x: len(x.split())
            get_label = lambda x: x.lower()
            # No use in removing literal duplicates
            skip_remove_duplicates = True
        else:
            logger.debug('Filtering results')
            get_len = lambda x: len(x['properties']['ngram'][0].split())
            get_label = lambda x: x[LABEL_PROP].lower()
            skip_remove_duplicates = False

        return self._filter_results(results, get_len, get_label, skip_remove_duplicates)

    def query(self, text, candidates=False):
        """
        Query the ARPA service and return the response results as JSON

        Results will be filtered if a filter was specified at init.

        `text` is the text used in the query.

        If `candidates` is set, query for candidates only.
        """

        logger.debug('Query ARPA at {} with text {}'.format(self._url, text))

        if not text:
            raise ValueError('Empty ARPA query text')

        url = self._url + ('?cgen' if candidates else '')

        # Query the ARPA service with the text
        data = {'text': text}

        res = post(url, data, retries=self._retries, wait=self._wait)

        return self._filter(res.get('results', []), candidates)

    def extract_uris(self, results):
        """
        Get the URIs from results.

        `results` is the results as returned by `arpa.query`.
        """
        return [URIRef(x['id']) for x in results]

    def get_distinct_mentions(self, results):
        """
        Get distinct mentions (i.e. matches) that yielded results.

        `results` is the results as returned by `arpa.query`.
        """
        return {m for ml in [p['matches'] for p in results] for m in ml}

    def get_uri_matches(self, text, *args, validator=None, **kwargs):
        """
        Query ARPA and return a dict with a list of uris of resources that match the text.

        Return a dict where 'results' has the list of uris, 'mentions' has the mentions
        that yielded results, and 'pre_validation_mentions' has mentions that yielded
        results before running the `validator`.

        `text` is the text to use in the query.

        `validator` is an object that implements a `validate` method that takes
        the results and `text` (and any other parameters passed to this method)
        as parameters, and returns a subset of the results.
        """

        logger.info('Getting URI matches: {}'.format(text))

        results = self.query(text)

        pre_validation_mentions = set()
        post_validation_mentions = set()

        if validator and results:
            logger.debug('Validating results: {}'.format(results))
            pre_validation_mentions = self.get_distinct_mentions(results)
            logger.info('Distinct mentions before validation: {} ({})'.format(len(pre_validation_mentions), pre_validation_mentions))
            results = validator.validate(results, text, *args, **kwargs)

        if results:
            logger.info('Found matches {}'.format(results))
            post_validation_mentions = self.get_distinct_mentions(results)
            logger.info('Distinct mentions: {} ({})'.format(len(post_validation_mentions), post_validation_mentions))
            results = self.extract_uris(results)
        else:
            logger.info('No matches found'.format(text))

        return {
            'results': results,
            'mentions': post_validation_mentions,
            'pre_validation_mentions': pre_validation_mentions
        }

    def get_candidates(self, text, *args, **kwargs):
        """
        Get the candidates from `text` that would be used by the ARPA service
        to query for matches.

        A dict is returned for compatibility with `arpa.get_uri_matches`.

        Return a dict where 'results' has the candidates as a list of rdflib Literals.
        """

        if not text:
            raise ValueError('Empty ARPA query text')

        res = self.query(text, candidates=True)

        logger.debug('Received candidates: {}'.format(res))

        result = {'results': [Literal(candidate) for candidate in res]}

        return result
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#arpa.Arpa">Arpa</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="arpa.Arpa.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, url, remove_duplicates=False, min_ngram_length=1, ignore=None, retries=0, wait_between_tries=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the Arpa service object.</p>
<p><code>url</code> is the ARPA service url.</p>
<p>If <code>remove_duplicates</code> is <code>True</code>, choose only one subject out of all the
matched subjects that have the same label (arbitrarily).
If, instead, the value is a list or a tuple, assume that it represents
a list of class names and prefer those classes when choosing
the subject. The ARPA results must include a property (<a href="#arpa.TYPE_PROP"><code>TYPE_PROP</code></a>)
that has the class of the match as the value. Optional.</p>
<p><code>min_ngram_length</code> is the minimum ngram match length that will be included when
returning the query results. Optional.</p>
<p><code>ignore</code> is a list of matches that should be removed from the results (case insensitive).
Optional.</p>
<p><code>retries</code> is the number of retries per query. Optional.</p>
<p><code>wait_between_tries</code> is the amount of times in seconds to wait between retries.
Optional, default is 1 second. Has no effect if <code>retries</code> is not set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.Arpa.__init__', this);">Show source &equiv;</a></p>
  <div id="source-arpa.Arpa.__init__" class="source">
    <pre><code>def __init__(self, url, remove_duplicates=False, min_ngram_length=1, ignore=None,
        retries=0, wait_between_tries=1):
    """
    Initialize the Arpa service object.
    `url` is the ARPA service url.
    If `remove_duplicates` is `True`, choose only one subject out of all the
    matched subjects that have the same label (arbitrarily).
    If, instead, the value is a list or a tuple, assume that it represents
    a list of class names and prefer those classes when choosing
    the subject. The ARPA results must include a property (`arpa.TYPE_PROP`)
    that has the class of the match as the value. Optional.
    `min_ngram_length` is the minimum ngram match length that will be included when
    returning the query results. Optional.
    `ignore` is a list of matches that should be removed from the results (case insensitive).
    Optional.
    `retries` is the number of retries per query. Optional.
    `wait_between_tries` is the amount of times in seconds to wait between retries.
    Optional, default is 1 second. Has no effect if `retries` is not set.
    """
    logger.debug('Initialize Arpa instance')
    if retries < 0:
        raise ValueError('Number of retries has to be a non-negative number, got {}'
                .format(retries))
    if wait_between_tries < 0:
        raise ValueError('Retry wait time has to be a non-negative number, got {}'
                .format(wait_between_tries))
    self._retries = retries
    self._url = url
    self._ignore = [s.lower() for s in ignore or []]
    self._min_ngram_length = min_ngram_length
    self._wait = wait_between_tries
    if type(remove_duplicates) == bool:
        self._no_duplicates = remove_duplicates
    else:
        self._no_duplicates = tuple('<{}>'.format(x) for x in remove_duplicates)
    logger.debug('ARPA ignore set to {}'.format(self._ignore))
    logger.debug('ARPA url set to {}'.format(self._url))
    logger.debug('ARPA min_ngram_length set to {}'.format(self._min_ngram_length))
    logger.debug('ARPA no_duplicates set to {}'.format(self._no_duplicates))
    logger.debug('ARPA retries set to {}'.format(self._retries))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.Arpa.extract_uris">
    <p>def <span class="ident">extract_uris</span>(</p><p>self, results)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the URIs from results.</p>
<p><code>results</code> is the results as returned by <code>arpa.query</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.Arpa.extract_uris', this);">Show source &equiv;</a></p>
  <div id="source-arpa.Arpa.extract_uris" class="source">
    <pre><code>def extract_uris(self, results):
    """
    Get the URIs from results.
    `results` is the results as returned by `arpa.query`.
    """
    return [URIRef(x['id']) for x in results]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.Arpa.get_candidates">
    <p>def <span class="ident">get_candidates</span>(</p><p>self, text, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the candidates from <code>text</code> that would be used by the ARPA service
to query for matches.</p>
<p>A dict is returned for compatibility with <code>arpa.get_uri_matches</code>.</p>
<p>Return a dict where 'results' has the candidates as a list of rdflib Literals.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.Arpa.get_candidates', this);">Show source &equiv;</a></p>
  <div id="source-arpa.Arpa.get_candidates" class="source">
    <pre><code>def get_candidates(self, text, *args, **kwargs):
    """
    Get the candidates from `text` that would be used by the ARPA service
    to query for matches.
    A dict is returned for compatibility with `arpa.get_uri_matches`.
    Return a dict where 'results' has the candidates as a list of rdflib Literals.
    """
    if not text:
        raise ValueError('Empty ARPA query text')
    res = self.query(text, candidates=True)
    logger.debug('Received candidates: {}'.format(res))
    result = {'results': [Literal(candidate) for candidate in res]}
    return result
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.Arpa.get_distinct_mentions">
    <p>def <span class="ident">get_distinct_mentions</span>(</p><p>self, results)</p>
    </div>
    

    
  
    <div class="desc"><p>Get distinct mentions (i.e. matches) that yielded results.</p>
<p><code>results</code> is the results as returned by <code>arpa.query</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.Arpa.get_distinct_mentions', this);">Show source &equiv;</a></p>
  <div id="source-arpa.Arpa.get_distinct_mentions" class="source">
    <pre><code>def get_distinct_mentions(self, results):
    """
    Get distinct mentions (i.e. matches) that yielded results.
    `results` is the results as returned by `arpa.query`.
    """
    return {m for ml in [p['matches'] for p in results] for m in ml}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.Arpa.get_uri_matches">
    <p>def <span class="ident">get_uri_matches</span>(</p><p>self, text, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Query ARPA and return a dict with a list of uris of resources that match the text.</p>
<p>Return a dict where 'results' has the list of uris, 'mentions' has the mentions
that yielded results, and 'pre_validation_mentions' has mentions that yielded
results before running the <code>validator</code>.</p>
<p><code>text</code> is the text to use in the query.</p>
<p><code>validator</code> is an object that implements a <code>validate</code> method that takes
the results and <code>text</code> (and any other parameters passed to this method)
as parameters, and returns a subset of the results.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.Arpa.get_uri_matches', this);">Show source &equiv;</a></p>
  <div id="source-arpa.Arpa.get_uri_matches" class="source">
    <pre><code>def get_uri_matches(self, text, *args, validator=None, **kwargs):
    """
    Query ARPA and return a dict with a list of uris of resources that match the text.
    Return a dict where 'results' has the list of uris, 'mentions' has the mentions
    that yielded results, and 'pre_validation_mentions' has mentions that yielded
    results before running the `validator`.
    `text` is the text to use in the query.
    `validator` is an object that implements a `validate` method that takes
    the results and `text` (and any other parameters passed to this method)
    as parameters, and returns a subset of the results.
    """
    logger.info('Getting URI matches: {}'.format(text))
    results = self.query(text)
    pre_validation_mentions = set()
    post_validation_mentions = set()
    if validator and results:
        logger.debug('Validating results: {}'.format(results))
        pre_validation_mentions = self.get_distinct_mentions(results)
        logger.info('Distinct mentions before validation: {} ({})'.format(len(pre_validation_mentions), pre_validation_mentions))
        results = validator.validate(results, text, *args, **kwargs)
    if results:
        logger.info('Found matches {}'.format(results))
        post_validation_mentions = self.get_distinct_mentions(results)
        logger.info('Distinct mentions: {} ({})'.format(len(post_validation_mentions), post_validation_mentions))
        results = self.extract_uris(results)
    else:
        logger.info('No matches found'.format(text))
    return {
        'results': results,
        'mentions': post_validation_mentions,
        'pre_validation_mentions': pre_validation_mentions
    }
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.Arpa.query">
    <p>def <span class="ident">query</span>(</p><p>self, text, candidates=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Query the ARPA service and return the response results as JSON</p>
<p>Results will be filtered if a filter was specified at init.</p>
<p><code>text</code> is the text used in the query.</p>
<p>If <code>candidates</code> is set, query for candidates only.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.Arpa.query', this);">Show source &equiv;</a></p>
  <div id="source-arpa.Arpa.query" class="source">
    <pre><code>def query(self, text, candidates=False):
    """
    Query the ARPA service and return the response results as JSON
    Results will be filtered if a filter was specified at init.
    `text` is the text used in the query.
    If `candidates` is set, query for candidates only.
    """
    logger.debug('Query ARPA at {} with text {}'.format(self._url, text))
    if not text:
        raise ValueError('Empty ARPA query text')
    url = self._url + ('?cgen' if candidates else '')
    # Query the ARPA service with the text
    data = {'text': text}
    res = post(url, data, retries=self._retries, wait=self._wait)
    return self._filter(res.get('results', []), candidates)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="arpa.ArpaMimic" class="name">class <span class="ident">ArpaMimic</span></p>
      
  
    <div class="desc"><p>Class that behaves like <a href="#arpa.Arpa"><code>Arpa</code></a> except that it queries a SPARQL endpoint
instead of an ARPA service.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.ArpaMimic', this);">Show source &equiv;</a></p>
  <div id="source-arpa.ArpaMimic" class="source">
    <pre><code>class ArpaMimic(Arpa):
    """
    Class that behaves like `arpa.Arpa` except that it queries a SPARQL endpoint
    instead of an ARPA service.
    """

    def __init__(self, query_template, *args, **kwargs):
        """
        Initialize the ArpaMimic instance.

        `query_template` is a SPARQL query template like ARPA uses.
        """

        self.query_template = query_template

        super().__init__(*args, **kwargs)

    def query(self, text, url_params=''):
        """
        Query a SPARQL endpoint and return the response results as JSON mapped
        as if returned by ARPA.

        `text` is the text used in the query.

        `url_params` is any URL parameters to be added to the URL.
        """

        logger.debug('Querying {} with text {} using ArpaMimic'.format(self._url, text))

        if not text:
            raise ValueError('Empty query text')

        query = self.query_template.replace('<VALUES>', text)

        url = self._url + url_params

        # Query the endpoint with the text
        data = {'query': query}

        res = post(url, data, retries=self._retries, wait=self._wait)

        res = map_results(res)

        return self._filter(res.get('results', []))
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#arpa.ArpaMimic">ArpaMimic</a></li>
          <li><a href="#arpa.Arpa">Arpa</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="arpa.ArpaMimic.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, query_template, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the ArpaMimic instance.</p>
<p><code>query_template</code> is a SPARQL query template like ARPA uses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.ArpaMimic.__init__', this);">Show source &equiv;</a></p>
  <div id="source-arpa.ArpaMimic.__init__" class="source">
    <pre><code>def __init__(self, query_template, *args, **kwargs):
    """
    Initialize the ArpaMimic instance.
    `query_template` is a SPARQL query template like ARPA uses.
    """
    self.query_template = query_template
    super().__init__(*args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.ArpaMimic.extract_uris">
    <p>def <span class="ident">extract_uris</span>(</p><p>self, results)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the URIs from results.</p>
<p><code>results</code> is the results as returned by <code>arpa.query</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.ArpaMimic.extract_uris', this);">Show source &equiv;</a></p>
  <div id="source-arpa.ArpaMimic.extract_uris" class="source">
    <pre><code>def extract_uris(self, results):
    """
    Get the URIs from results.
    `results` is the results as returned by `arpa.query`.
    """
    return [URIRef(x['id']) for x in results]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.ArpaMimic.get_candidates">
    <p>def <span class="ident">get_candidates</span>(</p><p>self, text, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the candidates from <code>text</code> that would be used by the ARPA service
to query for matches.</p>
<p>A dict is returned for compatibility with <code>arpa.get_uri_matches</code>.</p>
<p>Return a dict where 'results' has the candidates as a list of rdflib Literals.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.ArpaMimic.get_candidates', this);">Show source &equiv;</a></p>
  <div id="source-arpa.ArpaMimic.get_candidates" class="source">
    <pre><code>def get_candidates(self, text, *args, **kwargs):
    """
    Get the candidates from `text` that would be used by the ARPA service
    to query for matches.
    A dict is returned for compatibility with `arpa.get_uri_matches`.
    Return a dict where 'results' has the candidates as a list of rdflib Literals.
    """
    if not text:
        raise ValueError('Empty ARPA query text')
    res = self.query(text, candidates=True)
    logger.debug('Received candidates: {}'.format(res))
    result = {'results': [Literal(candidate) for candidate in res]}
    return result
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.ArpaMimic.get_distinct_mentions">
    <p>def <span class="ident">get_distinct_mentions</span>(</p><p>self, results)</p>
    </div>
    

    
  
    <div class="desc"><p>Get distinct mentions (i.e. matches) that yielded results.</p>
<p><code>results</code> is the results as returned by <code>arpa.query</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.ArpaMimic.get_distinct_mentions', this);">Show source &equiv;</a></p>
  <div id="source-arpa.ArpaMimic.get_distinct_mentions" class="source">
    <pre><code>def get_distinct_mentions(self, results):
    """
    Get distinct mentions (i.e. matches) that yielded results.
    `results` is the results as returned by `arpa.query`.
    """
    return {m for ml in [p['matches'] for p in results] for m in ml}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.ArpaMimic.get_uri_matches">
    <p>def <span class="ident">get_uri_matches</span>(</p><p>self, text, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Query ARPA and return a dict with a list of uris of resources that match the text.</p>
<p>Return a dict where 'results' has the list of uris, 'mentions' has the mentions
that yielded results, and 'pre_validation_mentions' has mentions that yielded
results before running the <code>validator</code>.</p>
<p><code>text</code> is the text to use in the query.</p>
<p><code>validator</code> is an object that implements a <code>validate</code> method that takes
the results and <code>text</code> (and any other parameters passed to this method)
as parameters, and returns a subset of the results.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.ArpaMimic.get_uri_matches', this);">Show source &equiv;</a></p>
  <div id="source-arpa.ArpaMimic.get_uri_matches" class="source">
    <pre><code>def get_uri_matches(self, text, *args, validator=None, **kwargs):
    """
    Query ARPA and return a dict with a list of uris of resources that match the text.
    Return a dict where 'results' has the list of uris, 'mentions' has the mentions
    that yielded results, and 'pre_validation_mentions' has mentions that yielded
    results before running the `validator`.
    `text` is the text to use in the query.
    `validator` is an object that implements a `validate` method that takes
    the results and `text` (and any other parameters passed to this method)
    as parameters, and returns a subset of the results.
    """
    logger.info('Getting URI matches: {}'.format(text))
    results = self.query(text)
    pre_validation_mentions = set()
    post_validation_mentions = set()
    if validator and results:
        logger.debug('Validating results: {}'.format(results))
        pre_validation_mentions = self.get_distinct_mentions(results)
        logger.info('Distinct mentions before validation: {} ({})'.format(len(pre_validation_mentions), pre_validation_mentions))
        results = validator.validate(results, text, *args, **kwargs)
    if results:
        logger.info('Found matches {}'.format(results))
        post_validation_mentions = self.get_distinct_mentions(results)
        logger.info('Distinct mentions: {} ({})'.format(len(post_validation_mentions), post_validation_mentions))
        results = self.extract_uris(results)
    else:
        logger.info('No matches found'.format(text))
    return {
        'results': results,
        'mentions': post_validation_mentions,
        'pre_validation_mentions': pre_validation_mentions
    }
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="arpa.ArpaMimic.query">
    <p>def <span class="ident">query</span>(</p><p>self, text, url_params=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Query a SPARQL endpoint and return the response results as JSON mapped
as if returned by ARPA.</p>
<p><code>text</code> is the text used in the query.</p>
<p><code>url_params</code> is any URL parameters to be added to the URL.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-arpa.ArpaMimic.query', this);">Show source &equiv;</a></p>
  <div id="source-arpa.ArpaMimic.query" class="source">
    <pre><code>def query(self, text, url_params=''):
    """
    Query a SPARQL endpoint and return the response results as JSON mapped
    as if returned by ARPA.
    `text` is the text used in the query.
    `url_params` is any URL parameters to be added to the URL.
    """
    logger.debug('Querying {} with text {} using ArpaMimic'.format(self._url, text))
    if not text:
        raise ValueError('Empty query text')
    query = self.query_template.replace('<VALUES>', text)
    url = self._url + url_params
    # Query the endpoint with the text
    data = {'query': query}
    res = post(url, data, retries=self._retries, wait=self._wait)
    res = map_results(res)
    return self._filter(res.get('results', []))
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="arpa.ArpaMimic.query_template" class="name">var <span class="ident">query_template</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
